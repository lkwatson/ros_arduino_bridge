<launch>
    <arg name="urdf_file" default="$(find ros_arduino_python)/config/prsg2_description.urdf" />
    <param name="robot_description" textfile="$(arg urdf_file)" />

    <!--
    <arg name="map_file" default="$(find ros_arduino_python)/config/map/map_10x10_res0.05.yaml"/>
    <node name="map_server" pkg="map_server" type="map_server" args="$(arg map_file)">
        <rosparam>
frame_id: odom
        </rosparam>
    </node>

    <node name="move_base" pkg="move_base" type="move_base" output="screen">
        <param name="controller_frequency" value="3.0" />

        <rosparam file="$(find ros_arduino_python)/config/nav/common.yaml"
            ns="global_costmap" />
        <rosparam file="$(find ros_arduino_python)/config/nav/common.yaml"
            ns="local_costmap" />

        <rosparam file="$(find ros_arduino_python)/config/nav/odom_global_costmap.yaml" />
        <rosparam file="$(find ros_arduino_python)/config/nav/odom_local_costmap.yaml" />

        <rosparam file="$(find ros_arduino_python)/config/nav/base_local_planner.yaml" />
    </node>
    -->

    <node name="go_to_goal" pkg="diff_drive" type="diff_drive_go_to_goal" output="screen">
        <rosparam>
linear_tolerance: 0.1
kP: 0.3
kA: 0.8
kB: 0.15
        </rosparam>
    </node>

    <!-- Publish the robot state -->
    <node name="robot_state_publisher" pkg="robot_state_publisher" type="state_publisher">
        <param name="publish_frequency" value="10.0"/>
    </node>

    <!-- Provide simulated control of the robot joint angles -->
    <node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher">
        <param name="use_gui" value="False" />
        <param name="rate" value="10.0"/>
    </node>

    <node name="arduino" pkg="ros_arduino_python" type="arduino_node.py" output="screen">
        <rosparam>
# For a direct USB cable connection, the port name is typically
# /dev/ttyACM# where is # is a number such as 0, 1, 2, etc
# For a wireless connection like XBee, the port is typically
# /dev/ttyUSB# where # is a number such as 0, 1, 2, etc.

port: /dev/ttyAMA0
baud: 115200
timeout: 0.5

rate: 10
sensorstate_rate: 10

use_base_controller: True
base_controller_rate: 10

# For a robot that uses base_footprint, change base_frame to base_footprint
base_frame: base_link

# === Robot drivetrain parameters
wheel_diameter: 0.060
wheel_track: 0.203
encoder_resolution: 48 # from Pololu for 130rpm motors
gear_reduction: 46.8512
motors_reversed: False

# === PID parameters
Kp: 100
Kd: 0
Ki: 0
Ko: 100
#accel_limit: 1.0

# === Sensor definitions.  Examples only - edit for your robot.
#     Sensor type can be one of the follow (case sensitive!):
# * Ping
# * GP2D12
# * Analog
# * Digital
# * PololuMotorCurrent
# * PhidgetsVoltage
# * PhidgetsCurrent (20 Amp, DC)

sensors: {
  ir_1:            {pin: 0, type: GP2Y0A60, rate: 10, frame: 'ir_left_link'},
  ir_2:            {pin: 2, type: GP2Y0A60, rate: 10,
                    frame: 'ir_left_front_link'},
  ir_3:            {pin: 3, type: GP2Y0A60, rate: 10, frame: 'ir_front_link'},
  ir_4:            {pin: 4, type: GP2Y0A60, rate: 10,
                    frame: 'ir_right_front_link'},
  ir_5:            {pin: 5, type: GP2Y0A60, rate: 10, frame: 'ir_right_link'},
  button_a:        {pin: 100, type: Digital, rate: 10},
  button_b:        {pin: 101, type: Digital, rate: 10},
# Cannot use button C because reading it interferes with motor 1 PWM.
#  button_c:       {pin: 102, type: Digital, rate: 10},
  battery_voltage: {pin: 106, type: Analog, rate: 1},
#  arduino_led:     {pin: 13, type: Digital, rate: 10, direction: output},
}
        </rosparam>
    </node>
</launch>
